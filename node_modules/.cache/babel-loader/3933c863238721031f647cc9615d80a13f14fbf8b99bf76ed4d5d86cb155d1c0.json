{"ast":null,"code":"import { p as e, v as t, g as r } from \"./_chunks-es/_commonjsHelpers.js\";\nconst o = [\"request\", \"response\", \"progress\", \"error\", \"abort\"],\n  s = [\"processOptions\", \"validateOptions\", \"interceptRequest\", \"finalizeOptions\", \"onRequest\", \"onResponse\", \"onError\", \"onReturn\", \"onHeaders\"];\nfunction n(r, a) {\n  const i = [],\n    u = s.reduce((e, t) => (e[t] = e[t] || [], e), {\n      processOptions: [e],\n      validateOptions: [t]\n    });\n  function l(e) {\n    const t = o.reduce((e, t) => (e[t] = function () {\n        const e = Object.create(null);\n        let t = 0;\n        return {\n          publish: function (t) {\n            for (const r in e) e[r](t);\n          },\n          subscribe: function (r) {\n            const o = t++;\n            return e[o] = r, function () {\n              delete e[o];\n            };\n          }\n        };\n      }(), e), {}),\n      r = (e => function (t, r, ...o) {\n        const s = \"onError\" === t;\n        let n = r;\n        for (let r = 0; r < e[t].length && (n = (0, e[t][r])(n, ...o), !s || n); r++);\n        return n;\n      })(u),\n      s = r(\"processOptions\", e);\n    r(\"validateOptions\", s);\n    const n = {\n      options: s,\n      channels: t,\n      applyMiddleware: r\n    };\n    let i;\n    const l = t.request.subscribe(e => {\n      i = a(e, (o, s) => ((e, o, s) => {\n        let n = e,\n          a = o;\n        if (!n) try {\n          a = r(\"onResponse\", o, s);\n        } catch (e) {\n          a = null, n = e;\n        }\n        n = n && r(\"onError\", n, s), n ? t.error.publish(n) : a && t.response.publish(a);\n      })(o, s, e));\n    });\n    t.abort.subscribe(() => {\n      l(), i && i.abort();\n    });\n    const c = r(\"onReturn\", t, n);\n    return c === t && t.request.publish(n), c;\n  }\n  return l.use = function (e) {\n    if (!e) throw new Error(\"Tried to add middleware that resolved to falsey value\");\n    if (\"function\" == typeof e) throw new Error(\"Tried to add middleware that was a function. It probably expects you to pass options to it.\");\n    if (e.onReturn && u.onReturn.length > 0) throw new Error(\"Tried to add new middleware with `onReturn` handler, but another handler has already been registered for this event\");\n    return s.forEach(t => {\n      e[t] && u[t].push(e[t]);\n    }), i.push(e), l;\n  }, l.clone = () => n(i, a), r.forEach(l.use), l;\n}\nvar a = function (e) {\n    return e.replace(/^\\s+|\\s+$/g, \"\");\n  },\n  i = r(function (e) {\n    if (!e) return {};\n    for (var t = {}, r = a(e).split(\"\\n\"), o = 0; o < r.length; o++) {\n      var s = r[o],\n        n = s.indexOf(\":\"),\n        i = a(s.slice(0, n)).toLowerCase(),\n        u = a(s.slice(n + 1));\n      typeof t[i] > \"u\" ? t[i] = u : (l = t[i], \"[object Array]\" === Object.prototype.toString.call(l) ? t[i].push(u) : t[i] = [t[i], u]);\n    }\n    var l;\n    return t;\n  });\nclass u {\n  onabort;\n  onerror;\n  onreadystatechange;\n  ontimeout;\n  readyState = 0;\n  response;\n  responseText = \"\";\n  responseType = \"\";\n  status;\n  statusText;\n  withCredentials;\n  #e;\n  #t;\n  #r;\n  #o = {};\n  #s;\n  #n = {};\n  #a;\n  open(e, t, r) {\n    this.#e = e, this.#t = t, this.#r = \"\", this.readyState = 1, this.onreadystatechange?.(), this.#s = void 0;\n  }\n  abort() {\n    this.#s && this.#s.abort();\n  }\n  getAllResponseHeaders() {\n    return this.#r;\n  }\n  setRequestHeader(e, t) {\n    this.#o[e] = t;\n  }\n  setInit(e, t = !0) {\n    this.#n = e, this.#a = t;\n  }\n  send(e) {\n    const t = \"arraybuffer\" !== this.responseType,\n      r = {\n        ...this.#n,\n        method: this.#e,\n        headers: this.#o,\n        body: e\n      };\n    \"function\" == typeof AbortController && this.#a && (this.#s = new AbortController(), typeof EventTarget < \"u\" && this.#s.signal instanceof EventTarget && (r.signal = this.#s.signal)), typeof document < \"u\" && (r.credentials = this.withCredentials ? \"include\" : \"omit\"), fetch(this.#t, r).then(e => (e.headers.forEach((e, t) => {\n      this.#r += `${t}: ${e}\\r\\n`;\n    }), this.status = e.status, this.statusText = e.statusText, this.readyState = 3, this.onreadystatechange?.(), t ? e.text() : e.arrayBuffer())).then(e => {\n      \"string\" == typeof e ? this.responseText = e : this.response = e, this.readyState = 4, this.onreadystatechange?.();\n    }).catch(e => {\n      \"AbortError\" !== e.name ? this.onerror?.(e) : this.onabort?.();\n    });\n  }\n}\nconst l = \"function\" == typeof XMLHttpRequest ? \"xhr\" : \"fetch\",\n  c = \"xhr\" === l ? XMLHttpRequest : u,\n  h = (e, t) => {\n    const r = e.options,\n      o = e.applyMiddleware(\"finalizeOptions\", r),\n      s = {},\n      n = e.applyMiddleware(\"interceptRequest\", void 0, {\n        adapter: l,\n        context: e\n      });\n    if (n) {\n      const e = setTimeout(t, 0, null, n);\n      return {\n        abort: () => clearTimeout(e)\n      };\n    }\n    let a = new c();\n    a instanceof u && \"object\" == typeof o.fetch && a.setInit(o.fetch, o.useAbortSignal ?? !0);\n    const h = o.headers,\n      d = o.timeout;\n    let p = !1,\n      f = !1,\n      b = !1;\n    if (a.onerror = e => {\n      m(a instanceof u ? e instanceof Error ? e : new Error(`Request error while attempting to reach is ${o.url}`, {\n        cause: e\n      }) : new Error(`Request error while attempting to reach is ${o.url}${e.lengthComputable ? `(${e.loaded} of ${e.total} bytes transferred)` : \"\"}`));\n    }, a.ontimeout = e => {\n      m(new Error(`Request timeout while attempting to reach ${o.url}${e.lengthComputable ? `(${e.loaded} of ${e.total} bytes transferred)` : \"\"}`));\n    }, a.onabort = () => {\n      w(!0), p = !0;\n    }, a.onreadystatechange = () => {\n      d && (w(), s.socket = setTimeout(() => y(\"ESOCKETTIMEDOUT\"), d.socket)), !p && 4 === a.readyState && 0 !== a.status && function () {\n        if (!(p || f || b)) {\n          if (0 === a.status) return void m(new Error(\"Unknown XHR error\"));\n          w(), f = !0, t(null, {\n            body: a.response || (\"\" === a.responseType || \"text\" === a.responseType ? a.responseText : \"\"),\n            url: o.url,\n            method: o.method,\n            headers: i(a.getAllResponseHeaders()),\n            statusCode: a.status,\n            statusMessage: a.statusText\n          });\n        }\n      }();\n    }, a.open(o.method, o.url, !0), a.withCredentials = !!o.withCredentials, h && a.setRequestHeader) for (const e in h) h.hasOwnProperty(e) && a.setRequestHeader(e, h[e]);\n    return o.rawBody && (a.responseType = \"arraybuffer\"), e.applyMiddleware(\"onRequest\", {\n      options: o,\n      adapter: l,\n      request: a,\n      context: e\n    }), a.send(o.body || null), d && (s.connect = setTimeout(() => y(\"ETIMEDOUT\"), d.connect)), {\n      abort: function () {\n        p = !0, a && a.abort();\n      }\n    };\n    function y(t) {\n      b = !0, a.abort();\n      const r = new Error(\"ESOCKETTIMEDOUT\" === t ? `Socket timed out on request to ${o.url}` : `Connection timed out on request to ${o.url}`);\n      r.code = t, e.channels.error.publish(r);\n    }\n    function w(e) {\n      (e || p || a.readyState >= 2 && s.connect) && clearTimeout(s.connect), s.socket && clearTimeout(s.socket);\n    }\n    function m(e) {\n      if (f) return;\n      w(!0), f = !0, a = null;\n      const r = e || new Error(`Network error while attempting to reach ${o.url}`);\n      r.isNetworkError = !0, r.request = o, t(r);\n    }\n  },\n  d = (e = [], t = h) => n(e, t),\n  p = \"browser\";\nexport { l as adapter, p as environment, d as getIt };","map":{"version":3,"names":["e","v","t","g","r","o","s","n","a","i","u","reduce","processOptions","validateOptions","l","Object","create","publish","subscribe","length","options","channels","applyMiddleware","request","error","response","abort","c","use","Error","onReturn","forEach","push","clone","trim","replace","split","indexOf","slice","toLowerCase","prototype","toString","call","onabort","onerror","onreadystatechange","ontimeout","readyState","responseText","responseType","status","statusText","withCredentials","open","getAllResponseHeaders","setRequestHeader","setInit","send","method","headers","body","AbortController","EventTarget","signal","document","credentials","fetch","then","text","arrayBuffer","catch","name","XMLHttpRequest","h","httpRequester","adapter","context","setTimeout","clearTimeout","useAbortSignal","d","timeout","p","f","b","m","url","cause","lengthComputable","loaded","total","w","socket","y","statusCode","statusMessage","hasOwnProperty","rawBody","connect","code","isNetworkError","getIt","environment"],"sources":["/home/baragu/Documents/search window/node_modules/get-it/src/util/middlewareReducer.ts","/home/baragu/Documents/search window/node_modules/get-it/src/createRequester.ts","/home/baragu/Documents/search window/node_modules/get-it/src/util/pubsub.ts","/home/baragu/Documents/search window/node_modules/get-it/node_modules/parse-headers/parse-headers.js","/home/baragu/Documents/search window/node_modules/get-it/src/request/browser/fetchXhr.ts","/home/baragu/Documents/search window/node_modules/get-it/src/request/browser-request.ts","/home/baragu/Documents/search window/node_modules/get-it/src/index.browser.ts"],"sourcesContent":["import type {ApplyMiddleware, MiddlewareReducer} from 'get-it'\n\nexport const middlewareReducer = (middleware: MiddlewareReducer) =>\n  function applyMiddleware(hook, defaultValue, ...args) {\n    const bailEarly = hook === 'onError'\n\n    let value = defaultValue\n    for (let i = 0; i < middleware[hook].length; i++) {\n      const handler = middleware[hook][i]\n      // @ts-expect-error -- find a better way to deal with argument tuples\n      value = handler(value, ...args)\n\n      if (bailEarly && !value) {\n        break\n      }\n    }\n\n    return value\n  } as ApplyMiddleware\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport {processOptions} from './middleware/defaultOptionsProcessor'\nimport {validateOptions} from './middleware/defaultOptionsValidator'\nimport type {\n  HttpContext,\n  HttpRequest,\n  HttpRequestOngoing,\n  Middleware,\n  MiddlewareChannels,\n  MiddlewareHooks,\n  MiddlewareReducer,\n  MiddlewareResponse,\n  Middlewares,\n  Requester,\n  RequestOptions,\n} from './types'\nimport {middlewareReducer} from './util/middlewareReducer'\nimport {createPubSub} from './util/pubsub'\n\nconst channelNames = [\n  'request',\n  'response',\n  'progress',\n  'error',\n  'abort',\n] satisfies (keyof MiddlewareChannels)[]\nconst middlehooks = [\n  'processOptions',\n  'validateOptions',\n  'interceptRequest',\n  'finalizeOptions',\n  'onRequest',\n  'onResponse',\n  'onError',\n  'onReturn',\n  'onHeaders',\n] satisfies (keyof MiddlewareHooks)[]\n\n/** @public */\nexport function createRequester(initMiddleware: Middlewares, httpRequest: HttpRequest): Requester {\n  const loadedMiddleware: Middlewares = []\n  const middleware: MiddlewareReducer = middlehooks.reduce(\n    (ware, name) => {\n      ware[name] = ware[name] || []\n      return ware\n    },\n    {\n      processOptions: [processOptions],\n      validateOptions: [validateOptions],\n    } as any,\n  )\n\n  function request(opts: RequestOptions | string) {\n    const onResponse = (reqErr: Error | null, res: MiddlewareResponse, ctx: HttpContext) => {\n      let error = reqErr\n      let response: MiddlewareResponse | null = res\n\n      // We're processing non-errors first, in case a middleware converts the\n      // response into an error (for instance, status >= 400 == HttpError)\n      if (!error) {\n        try {\n          response = applyMiddleware('onResponse', res, ctx)\n        } catch (err: any) {\n          response = null\n          error = err\n        }\n      }\n\n      // Apply error middleware - if middleware return the same (or a different) error,\n      // publish as an error event. If we *don't* return an error, assume it has been handled\n      error = error && applyMiddleware('onError', error, ctx)\n\n      // Figure out if we should publish on error/response channels\n      if (error) {\n        channels.error.publish(error)\n      } else if (response) {\n        channels.response.publish(response)\n      }\n    }\n\n    const channels: MiddlewareChannels = channelNames.reduce((target, name) => {\n      target[name] = createPubSub() as MiddlewareChannels[typeof name]\n      return target\n    }, {} as any)\n\n    // Prepare a middleware reducer that can be reused throughout the lifecycle\n    const applyMiddleware = middlewareReducer(middleware)\n\n    // Parse the passed options\n    const options = applyMiddleware('processOptions', opts as RequestOptions)\n\n    // Validate the options\n    applyMiddleware('validateOptions', options)\n\n    // Build a context object we can pass to child handlers\n    const context = {options, channels, applyMiddleware}\n\n    // We need to hold a reference to the current, ongoing request,\n    // in order to allow cancellation. In the case of the retry middleware,\n    // a new request might be triggered\n    let ongoingRequest: HttpRequestOngoing | undefined\n    const unsubscribe = channels.request.subscribe((ctx) => {\n      // Let request adapters (node/browser) perform the actual request\n      ongoingRequest = httpRequest(ctx, (err, res) => onResponse(err, res!, ctx))\n    })\n\n    // If we abort the request, prevent further requests from happening,\n    // and be sure to cancel any ongoing request (obviously)\n    channels.abort.subscribe(() => {\n      unsubscribe()\n      if (ongoingRequest) {\n        ongoingRequest.abort()\n      }\n    })\n\n    // See if any middleware wants to modify the return value - for instance\n    // the promise or observable middlewares\n    const returnValue = applyMiddleware('onReturn', channels, context)\n\n    // If return value has been modified by a middleware, we expect the middleware\n    // to publish on the 'request' channel. If it hasn't been modified, we want to\n    // trigger it right away\n    if (returnValue === channels) {\n      channels.request.publish(context)\n    }\n\n    return returnValue\n  }\n\n  request.use = function use(newMiddleware: Middleware) {\n    if (!newMiddleware) {\n      throw new Error('Tried to add middleware that resolved to falsey value')\n    }\n\n    if (typeof newMiddleware === 'function') {\n      throw new Error(\n        'Tried to add middleware that was a function. It probably expects you to pass options to it.',\n      )\n    }\n\n    if (newMiddleware.onReturn && middleware.onReturn.length > 0) {\n      throw new Error(\n        'Tried to add new middleware with `onReturn` handler, but another handler has already been registered for this event',\n      )\n    }\n\n    middlehooks.forEach((key) => {\n      if (newMiddleware[key]) {\n        middleware[key].push(newMiddleware[key] as any)\n      }\n    })\n\n    loadedMiddleware.push(newMiddleware)\n    return request\n  }\n\n  request.clone = () => createRequester(loadedMiddleware, httpRequest)\n\n  initMiddleware.forEach(request.use)\n\n  return request\n}\n","// Code borrowed from https://github.com/bjoerge/nano-pubsub\n\nimport type {PubSub, Subscriber} from 'get-it'\n\nexport function createPubSub<Message = void>(): PubSub<Message> {\n  const subscribers: {[id: string]: Subscriber<Message>} = Object.create(null)\n  let nextId = 0\n  function subscribe(subscriber: Subscriber<Message>) {\n    const id = nextId++\n    subscribers[id] = subscriber\n    return function unsubscribe() {\n      delete subscribers[id]\n    }\n  }\n\n  function publish(event: Message) {\n    for (const id in subscribers) {\n      subscribers[id](event)\n    }\n  }\n\n  return {\n    publish,\n    subscribe,\n  }\n}\n","var trim = function(string) {\n  return string.replace(/^\\s+|\\s+$/g, '');\n}\n  , isArray = function(arg) {\n      return Object.prototype.toString.call(arg) === '[object Array]';\n    }\n\nmodule.exports = function (headers) {\n  if (!headers)\n    return {}\n\n  var result = {}\n\n  var headersArr = trim(headers).split('\\n')\n\n  for (var i = 0; i < headersArr.length; i++) {\n    var row = headersArr[i]\n    var index = row.indexOf(':')\n    , key = trim(row.slice(0, index)).toLowerCase()\n    , value = trim(row.slice(index + 1))\n\n    if (typeof(result[key]) === 'undefined') {\n      result[key] = value\n    } else if (isArray(result[key])) {\n      result[key].push(value)\n    } else {\n      result[key] = [ result[key], value ]\n    }\n  }\n\n  return result\n}\n","/**\n * Mimicks the XMLHttpRequest API with only the parts needed for get-it's XHR adapter\n */\nexport class FetchXhr\n  implements Pick<XMLHttpRequest, 'open' | 'abort' | 'getAllResponseHeaders' | 'setRequestHeader'>\n{\n  /**\n   * Public interface, interop with real XMLHttpRequest\n   */\n  onabort: (() => void) | undefined\n  onerror: ((error?: any) => void) | undefined\n  onreadystatechange: (() => void) | undefined\n  ontimeout: XMLHttpRequest['ontimeout'] | undefined\n  /**\n   * https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/readyState\n   */\n  readyState: 0 | 1 | 2 | 3 | 4 = 0\n  response: XMLHttpRequest['response']\n  responseText: XMLHttpRequest['responseText'] = ''\n  responseType: XMLHttpRequest['responseType'] = ''\n  status: XMLHttpRequest['status'] | undefined\n  statusText: XMLHttpRequest['statusText'] | undefined\n  withCredentials: XMLHttpRequest['withCredentials'] | undefined\n\n  /**\n   * Private implementation details\n   */\n  #method!: string\n  #url!: string\n  #resHeaders!: string\n  #headers: Record<string, string> = {}\n  #controller?: AbortController\n  #init: RequestInit = {}\n  #useAbortSignal?: boolean\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars -- _async is only declared for typings compatibility\n  open(method: string, url: string, _async?: boolean) {\n    this.#method = method\n    this.#url = url\n    this.#resHeaders = ''\n    this.readyState = 1 // Open\n    this.onreadystatechange?.()\n    this.#controller = undefined\n  }\n  abort() {\n    if (this.#controller) {\n      this.#controller.abort()\n    }\n  }\n  getAllResponseHeaders() {\n    return this.#resHeaders\n  }\n  setRequestHeader(name: string, value: string) {\n    this.#headers[name] = value\n  }\n  // Allow setting extra fetch init options, needed for runtimes such as Vercel Edge to set `cache` and other options in React Server Components\n  setInit(init: RequestInit, useAbortSignal = true) {\n    this.#init = init\n    this.#useAbortSignal = useAbortSignal\n  }\n  send(body: BodyInit) {\n    const textBody = this.responseType !== 'arraybuffer'\n    const options: RequestInit = {\n      ...this.#init,\n      method: this.#method,\n      headers: this.#headers,\n      body,\n    }\n    if (typeof AbortController === 'function' && this.#useAbortSignal) {\n      this.#controller = new AbortController()\n      // The instanceof check ensures environments like Edge Runtime, Node 18 with built-in fetch\n      // and more don't throw if `signal` doesn't implement`EventTarget`\n      // Native browser AbortSignal implements EventTarget, so we can use it\n      if (typeof EventTarget !== 'undefined' && this.#controller.signal instanceof EventTarget) {\n        options.signal = this.#controller.signal\n      }\n    }\n\n    // Some environments (like CloudFlare workers) don't support credentials in\n    // RequestInitDict, and there doesn't seem to be any easy way to check for it,\n    // so for now let's just make do with a document check :/\n    if (typeof document !== 'undefined') {\n      options.credentials = this.withCredentials ? 'include' : 'omit'\n    }\n\n    fetch(this.#url, options)\n      .then((res): Promise<string | ArrayBuffer> => {\n        res.headers.forEach((value: any, key: any) => {\n          this.#resHeaders += `${key}: ${value}\\r\\n`\n        })\n        this.status = res.status\n        this.statusText = res.statusText\n        this.readyState = 3 // Loading\n        this.onreadystatechange?.()\n        return textBody ? res.text() : res.arrayBuffer()\n      })\n      .then((resBody) => {\n        if (typeof resBody === 'string') {\n          this.responseText = resBody\n        } else {\n          this.response = resBody\n        }\n        this.readyState = 4 // Done\n        this.onreadystatechange?.()\n      })\n      .catch((err: Error) => {\n        if (err.name === 'AbortError') {\n          this.onabort?.()\n          return\n        }\n\n        this.onerror?.(err)\n      })\n  }\n}\n","import type {HttpRequest, MiddlewareResponse, RequestOptions} from 'get-it'\nimport parseHeaders from 'parse-headers'\n\nimport {FetchXhr} from './browser/fetchXhr'\n\n/**\n * Use fetch if it's available, non-browser environments such as Deno, Edge Runtime and more provide fetch as a global but doesn't provide xhr\n * @public\n */\nexport const adapter = (\n  typeof XMLHttpRequest === 'function' ? ('xhr' as const) : ('fetch' as const)\n) satisfies import('../types').RequestAdapter\n\n// Fallback to fetch-based XHR polyfill for non-browser environments like Workers\nconst XmlHttpRequest = adapter === 'xhr' ? XMLHttpRequest : FetchXhr\n\nexport const httpRequester: HttpRequest = (context, callback) => {\n  const opts = context.options\n  const options = context.applyMiddleware('finalizeOptions', opts) as RequestOptions\n  const timers: any = {}\n\n  // Allow middleware to inject a response, for instance in the case of caching or mocking\n  const injectedResponse = context.applyMiddleware('interceptRequest', undefined, {\n    adapter,\n    context,\n  })\n\n  // If middleware injected a response, treat it as we normally would and return it\n  // Do note that the injected response has to be reduced to a cross-environment friendly response\n  if (injectedResponse) {\n    const cbTimer = setTimeout(callback, 0, null, injectedResponse)\n    const cancel = () => clearTimeout(cbTimer)\n    return {abort: cancel}\n  }\n\n  // We'll want to null out the request on success/failure\n  let xhr = new XmlHttpRequest()\n\n  if (xhr instanceof FetchXhr && typeof options.fetch === 'object') {\n    xhr.setInit(options.fetch, options.useAbortSignal ?? true)\n  }\n\n  const headers = options.headers\n  const delays = options.timeout\n\n  // Request state\n  let aborted = false\n  let loaded = false\n  let timedOut = false\n\n  // Apply event handlers\n  xhr.onerror = (event: ProgressEvent) => {\n    // If fetch is used then rethrow the original error\n    if (xhr instanceof FetchXhr) {\n      onError(\n        event instanceof Error\n          ? event\n          : new Error(`Request error while attempting to reach is ${options.url}`, {cause: event}),\n      )\n    } else {\n      onError(\n        new Error(\n          `Request error while attempting to reach is ${options.url}${\n            event.lengthComputable ? `(${event.loaded} of ${event.total} bytes transferred)` : ''\n          }`,\n        ),\n      )\n    }\n  }\n  xhr.ontimeout = (event: ProgressEvent) => {\n    onError(\n      new Error(\n        `Request timeout while attempting to reach ${options.url}${\n          event.lengthComputable ? `(${event.loaded} of ${event.total} bytes transferred)` : ''\n        }`,\n      ),\n    )\n  }\n  xhr.onabort = () => {\n    stopTimers(true)\n    aborted = true\n  }\n\n  xhr.onreadystatechange = () => {\n    // Prevent request from timing out\n    resetTimers()\n\n    if (aborted || xhr.readyState !== 4) {\n      return\n    }\n\n    // Will be handled by onError\n    if (xhr.status === 0) {\n      return\n    }\n\n    onLoad()\n  }\n\n  // @todo two last options to open() is username/password\n  xhr.open(\n    options.method!,\n    options.url,\n    true, // Always async\n  )\n\n  // Some options need to be applied after open\n  xhr.withCredentials = !!options.withCredentials\n\n  // Set headers\n  if (headers && xhr.setRequestHeader) {\n    for (const key in headers) {\n      // eslint-disable-next-line no-prototype-builtins\n      if (headers.hasOwnProperty(key)) {\n        xhr.setRequestHeader(key, headers[key])\n      }\n    }\n  }\n\n  if (options.rawBody) {\n    xhr.responseType = 'arraybuffer'\n  }\n\n  // Let middleware know we're about to do a request\n  context.applyMiddleware('onRequest', {options, adapter, request: xhr, context})\n\n  xhr.send(options.body || null)\n\n  // Figure out which timeouts to use (if any)\n  if (delays) {\n    timers.connect = setTimeout(() => timeoutRequest('ETIMEDOUT'), delays.connect)\n  }\n\n  return {abort}\n\n  function abort() {\n    aborted = true\n\n    if (xhr) {\n      xhr.abort()\n    }\n  }\n\n  function timeoutRequest(code: any) {\n    timedOut = true\n    xhr.abort()\n    const error: any = new Error(\n      code === 'ESOCKETTIMEDOUT'\n        ? `Socket timed out on request to ${options.url}`\n        : `Connection timed out on request to ${options.url}`,\n    )\n    error.code = code\n    context.channels.error.publish(error)\n  }\n\n  function resetTimers() {\n    if (!delays) {\n      return\n    }\n\n    stopTimers()\n    timers.socket = setTimeout(() => timeoutRequest('ESOCKETTIMEDOUT'), delays.socket)\n  }\n\n  function stopTimers(force?: boolean) {\n    // Only clear the connect timeout if we've got a connection\n    if (force || aborted || (xhr.readyState >= 2 && timers.connect)) {\n      clearTimeout(timers.connect)\n    }\n\n    if (timers.socket) {\n      clearTimeout(timers.socket)\n    }\n  }\n\n  function onError(error: Error) {\n    if (loaded) {\n      return\n    }\n\n    // Clean up\n    stopTimers(true)\n    loaded = true\n    ;(xhr as any) = null\n\n    // Annoyingly, details are extremely scarce and hidden from us.\n    // We only really know that it is a network error\n    const err = (error ||\n      new Error(`Network error while attempting to reach ${options.url}`)) as Error & {\n      isNetworkError: boolean\n      request?: typeof options\n    }\n    err.isNetworkError = true\n    err.request = options\n    callback(err)\n  }\n\n  function reduceResponse(): MiddlewareResponse {\n    return {\n      body:\n        xhr.response ||\n        (xhr.responseType === '' || xhr.responseType === 'text' ? xhr.responseText : ''),\n      url: options.url,\n      method: options.method!,\n      headers: parseHeaders(xhr.getAllResponseHeaders()),\n      statusCode: xhr.status!,\n      statusMessage: xhr.statusText!,\n    }\n  }\n\n  function onLoad() {\n    if (aborted || loaded || timedOut) {\n      return\n    }\n\n    if (xhr.status === 0) {\n      onError(new Error('Unknown XHR error'))\n      return\n    }\n\n    // Prevent being called twice\n    stopTimers()\n    loaded = true\n    callback(null, reduceResponse())\n  }\n}\n","import {createRequester} from './createRequester'\nimport {httpRequester} from './request/browser-request'\nimport type {ExportEnv, HttpRequest, Middlewares, Requester} from './types'\n\nexport type * from './types'\n\n/** @public */\nexport const getIt = (\n  initMiddleware: Middlewares = [],\n  httpRequest: HttpRequest = httpRequester,\n): Requester => createRequester(initMiddleware, httpRequest)\n\n/** @public */\nexport const environment = 'browser' satisfies ExportEnv\n\n/** @public */\nexport {adapter} from './request/browser-request'\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}